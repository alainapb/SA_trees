---
title: "SA_tree_pgls"
author: "APB"
date: "4/8/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(caper)
library(picante)
library(raster)
library(scico)
library(pez)
```

```{r load_data, include = FALSE}
tree<-read.nexus("data/36runs_BI250000_12K_output.tre")
#plot(tree, cex = 0.03) #1852 tips
data<-read.csv("data/SA_tree_data.csv", header = TRUE)

summary(data)
```

```{r clean_data, include =FALSE}
#first pull Family name out of the tree tip labels
tree$tip.label<-gsub("^.*?_","", tree$tip.label)

#check similarity between tree tips and data
tree_data<-data[which(data$matrix_name %in% tree$tip.label),]
tree_data$height<-as.numeric(tree_data$height)
tree_data$length<-as.numeric(tree_data$length)
tree_data$width<-as.numeric(tree_data$width)
summary(tree_data)

#remove any blanks from map_name
filter(tree_data, map_name != "")->tree_data

length(unique(tree_data$map_name)) #there is data for 1085 map_names from the tree 

#subset the tree to only include taxa there is data for 
SA_tree<-drop.tip(tree, tree$tip.label[which(!(tree$tip.label %in% tree_data$matrix_name))])
#plot(SA_tree, cex = 0.3, type = "f")

```

```{r calculate PD, include = FALSE}
#interspecific distance matrix
distance_matrix<-cophenetic.phylo(SA_tree)

```


```{r pgls, echo = TRUE}

#make dataframe
dat<-data.frame(taxa=SA_tree$tip.label,
                height=tree_data$height, 
                leaf_shape=tree_data$ratio)

cdat<-comparative.data(data = dat, phy = SA_tree, names.col="taxa")

summary(pgls(log(height*1000) ~ leaf_shape, cdat, lambda = "ML")) #leaf shape predicts height ***; lambda = 0.267

summary(pgls(log(height*1000) ~ 1, cdat, lambda = "ML")) #lambda = 0.322

summary(pgls(leaf_shape ~ 1, cdat, lambda = "ML")) #lambda = 0.75

summary(lm(log(height*1000) ~ ratio, tree_data)) 

#subset the data to remove 'Exotic' species and NAs
tree_data %>%
  filter(height != "Exotic") %>%
  filter(height != "NA") %>% 
  filter(ratio != "NA")-> l

summary(l)

summary(gls(log(height * 1000) ~ ratio, data = l)) # significant negative correlation (-0.68) 
cor.test(log(l$height * 1000), l$ratio) # significant negative correlation
#with increasing tree height there are more round leaves

ggplot(l, mapping = aes(x=height*1000, y = ratio))+
  geom_point()+
  geom_smooth(method = "lm")+
  #xlim(limits =c(0, 20000))+
  theme_classic()

```

```{r load_shape_files, include = FALSE}
library(sf)

#See some info on plotting shape files here:
#https://r-spatial.github.io/sf/articles/sf5.html
SA_poly<-st_read("data/GIS_DATA/all_no_exotics.shp")
plot(st_geometry(SA_poly)) #Contains 1176 polygons

SA_grids<-st_read("data/GIS_DATA/SA_grid.shp")
plot(st_geometry(SA_grids))

z<-subset(SA_poly, SA_poly$shpname=="acacia_karroo.shp")
plot(st_geometry(SA_grids))
plot(st_geometry(z), col = "lightblue", add = T) #add = T is adding the polygon for z to the previous plot

# outline of countries in Southern Africa
use<-map_data("world", region = c("Angola","Botswana","Lesotho","Mozambique","Malawi:3","Namibia", "Swaziland", "South Africa", "Zambia","Zimbabwe")) %>%
  dplyr::select(lon = long, lat = lat, group, id= region)

#remove island
use<-filter(use, lat > -40)
```
#TO DO
## 1) overlay the grid and generate a simple species richness map
## 2) extract the list of species overlapping each grid cell and then calculate PD for each cell. 
## 3) map the median species trait values for each cell

###Notes: One way of doing all this is by ‘rasterising’ each species polygon, and then stacking them. Assign a ‘trait value’ to each raster (for species richness this would just be ‘1’), and then sum the values or take their mean etc. Some hints here: https://luisdva.github.io/rstats/richness/

#Species Richness Map
```{r, species_richness_map, echo = TRUE}
#QDS is quarter degree square grids

st_crs(SA_grids)<-4326
st_crs(SA_poly)
st_crs(SA_grids)

sf_use_s2(FALSE) # fixes the error with spherical geometry 

richness_grid <- SA_grids %>%
  st_join(SA_poly) %>%
  mutate(overlap = ifelse(!is.na(shpname), 1, 0)) %>% #1 if there is a shpname
  group_by(lat, long) %>%
  summarize(num_species = sum(overlap), 
            sp_names = list(shpname)) %>%
  mutate(ID = paste(lat, "_", long))


ggplot(richness_grid) +
  #geom_sf(data = SA_poly, fill = NA, size = 0.1) +
  geom_sf(aes(fill = num_species), color = NA) +
  scale_fill_scico(palette = "davos", direction = -1, end = 0.9, name = "Species richness") +
  geom_polygon(use, mapping=aes(lon, lat, group = group), fill = "transparent", colour = "black", size = 0.5)+
  theme_bw()+
  theme(
    #plot.background = element_rect(fill = "#f1f2f3"),
    #panel.background = element_rect(fill = "#2F4051"),
    #panel.grid = element_blank(),
    legend.position = "bottom",
    #line = element_blank(),
    #rect = element_blank()
  ) + labs(fill = "richness")

```
##Another way to calculate species richness
```{r another_way_to_count_species, include = FALSE}
usp <- unique(SA_poly$shpname)
r <- raster(res=0.5)
s <- list()
for (i in 1:length(usp)) {
    p <- SA_poly[SA_poly$shpname == usp[i], ]
    s[[i]] <- rasterize(p, r, field=1, fun="count")
}       
ss <- stack(s) 
sr <- sum(ss>0, na.rm=TRUE)

m <- as.matrix(ss)
m[is.na(m)] <- 0

i <- which(rowSums(m) > 0) # to remove rows with no species 
xy <- xyFromCell(r, i)  
output <- cbind(xy, m[i,])
colnames(output) <- c("lon", "lat", usp)


xx<-data.frame(long = output[,1], lat = output[,2])
xx$no_species<-rowSums(output[,3:1178]) #number of species at each lat long
```
#Calculate PD for each grid cell (ID)
```{r list_of_species_in_each_grid_cell, include = FALSE}
#### ses.mpd from 'picante'
#need a community matrix where ID are the rows and species names are the columns
comm_matrix<-data.frame(matrix(ncol= length(tree$tip.label)), nrow=unique(richness_grid$ID), row.names = unique(richness_grid$ID))
rownames(comm_matrix)<-unique(richness_grid$ID)
tree_names<-tree_data[match(tree$tip.label, tree_data$matrix_name, nomatch = NA),] #put tree_data in tree tip.label order so we can easily switch between map_name and matrix_name
tree_names<-subset(tree_names, map_name != "NA")
colnames(comm_matrix)<-tree_names$map_name #set column names to the map names to make the for loop simpler

for (i in 1:nrow(comm_matrix)){
 comm_matrix[i,] <- colnames(comm_matrix) %in% unlist(subset(richness_grid, ID == rownames(comm_matrix)[i])$sp_names) %>% as.numeric

}

str(comm_matrix)
k<-as.numeric(comm_matrix['-34.75 _ 19.75',]) # should have a sum of 101
sum(k) # it does!

#make column names match the tree tip labels 
colnames(comm_matrix)<-tree_names$matrix_name

#matrix has extra columns that are unnecessary
comm_matrix<-comm_matrix[,1:1085]

##code takes time to run
#ses_results <-ses.mpd(comm_matrix, distance_matrix, null.model = "taxa.labels", runs = 100) #30 minutes
##save output as RDS
#saveRDS(ses_results, "NRI_data.rds")
##read in ses.mpd results
NRI<-readRDS("NRI_data.rds") 
NRI$ID<-rownames(NRI)
```
#Map the mpd values for each cell
```{r mpd_plot, echo = TRUE}
right_join(richness_grid, NRI, by = "ID")->mpd_grid

ggplot(mpd_grid) +
  #geom_sf(data = SA_poly, fill = NA, size = 0.3) +
  geom_sf(aes(fill = mpd.obs), color = NA) +
  scale_fill_scico(palette = "davos", direction = -1, end = 0.9, name = "MPD") +
  geom_polygon(use, mapping=aes(lon, lat, group = group), fill = "transparent", colour = "black", size = 0.3)+
  theme_bw()+
  theme(
    #plot.background = element_rect(fill = "#f1f2f3"),
    #panel.background = element_rect(fill = "#2F4051"),
    #panel.grid = element_blank(),
    legend.position = "bottom",
    #line = element_blank(),
    #rect = element_blank()
    ) + labs(fill = "MPD")

ggplot(mpd_grid) +
  #geom_sf(data = SA_poly, fill = "white", color = "grey", size = 0.05) +
  geom_sf(data = SA_grids, fill = "white", color = "black", size = 0.4) +
  geom_sf(aes(fill = mpd.obs.p), color = NA) +
  scale_fill_scico(palette = "davos", direction = -1, end = 0.9, name = "quantiles (p)") +
  geom_polygon(use, mapping=aes(lon, lat, group = group), fill = "transparent", colour = "black", size = 0.3)+
  theme_bw()+
  theme(
    #plot.background = element_rect(fill = "#f1f2f3"),
    #panel.background = element_rect(fill = "#2F4051"),
    #panel.grid = element_blank(),
    legend.position = "bottom",
    #line = element_blank(),
    #rect = element_blank()
    ) + labs(fill = "quantiles (p)")
# high quantiles (mpd.obs.p > 0.95) indicate phylogenetic evenness, or a greater phylogenetic distance among co-occurring species than expected.
```
#Summarise tree traits for each grid cell 
```{r pull_medians_for_trait_data, include = FALSE}
#dataframe by ID that includes the median tree trait data for each ID 
trait_data<-data.frame(ID = unique(richness_grid$ID), 
                       count =NA, 
                       treeheight = NA,
                       leafshape = NA)

for (i in 1:nrow(trait_data)) {
  
  subset(tree_names, comm_matrix[i, ] == 1) ->j
  
  j%>%
   summarise(length(height)) -> trait_data$count[i]
  
  j%>%
   summarise(mean(height), na.rm = T) %>% unlist() -> trait_data$treeheight[i]
  
   j%>%
   summarise(mean(ratio), na.rm = T) %>% unlist() -> trait_data$leafshape[i]
}


#library(pez)
#community<-as.matrix(comm_matrix)
#traits<-with(tree_names, 
#             data.frame(treeheight = log(height *1000),
#                        leaflength = length, 
#                        leafwidth = width, 
#                        leafshape = ratio, 
#                        leafarea = leaf_area,
#                        row.names = matrix_name))
#compar_data <- comparative.comm(tree, 
#                    community, 
#                    traits)
#str(compar_data)

```

#Plot median tree traits per grid cell
```{r tree_trait_plots, echo =TRUE}
right_join(mpd_grid, trait_data, by = "ID")->trait_grid

ggplot(trait_grid) +
  #geom_sf(data = SA_poly, fill = NA, size = 0.3) +
  geom_sf(aes(fill = log(treeheight *1000)), color = NA) +
  scale_fill_scico(palette = "davos", direction = -1, end = 0.9, name = "Log (Tree Height in m)") +
  geom_polygon(use, mapping=aes(lon, lat, group = group), fill = "transparent", colour = "black", size = 0.3)+
  theme_bw()+
  theme(
    #plot.background = element_rect(fill = "#f1f2f3"),
    #panel.background = element_rect(fill = "#2F4051"),
    #panel.grid = element_blank(),
    legend.position = "bottom",
    #line = element_blank(),
    #rect = element_blank()
    ) + labs(fill = "Log (Tree Height in m)")

ggplot(trait_grid) +
  #geom_sf(data = SA_poly, fill = NA, size = 0.3) +
  geom_sf(aes(fill = leafshape), color = NA) +
  scale_fill_scico(palette = "davos", direction = -1, end = 0.9, name = "Leaf Shape") +
  geom_polygon(use, mapping=aes(lon, lat, group = group), fill = "transparent", colour = "black", size = 0.3)+
  theme_bw()+
  theme(
    #plot.background = element_rect(fill = "#f1f2f3"),
    #panel.background = element_rect(fill = "#2F4051"),
    #panel.grid = element_blank(),
    legend.position = "bottom",
    #line = element_blank(),
    #rect = element_blank()
    ) + labs(fill = "Leaf Shape")

```

#Rerun JD's Stats
```{r correlations_regressions, include = TRUE}
#Is there a correlation between mpd and species richness? 0.33 ***
cor.test(mpd_grid$mpd.obs, mpd_grid$ntaxa)

#Does mpd capture functional diversity? ...yes 57%
summary(lm(treeheight ~ mpd.obs * ntaxa, data =trait_grid))

#Is there a correlation between height and leaf shape? YES, tall trees have rounder leaves
cor.test(trait_grid$treeheight, trait_grid$leafshape) # -0.65 ***

#Is tree height explained by mpd and leaf shape?
summary(lm(log(treeheight) ~ mpd.obs + leafshape, data = trait_grid))
```

### need to pull AET data (and PET from some database) look for NPP net primary productivity data

```{r phylo_path_analysis, include = TRUE}
#Is there a correlation between leafshape and evapotranspiration?
#lm(leafshape ~ aet, data = ??)

#Is there a correlation between tree height and species richness? YES
summary(lm(treeheight ~ ntaxa, data =trait_grid)) #r = 0.479  ** this is the square of the correlation
cor.test(trait_grid$treeheight, trait_grid$ntaxa) #r = 0.691 

```
#Model of grid cells **** do next!
mpd is the response for the outcomes of the mayfield and levine 2010
 
moran's I on the residuals(autocorrelation in space) use the spatial data only (we want it to be low)
```{r models, include = TRUE}
#need to add AET or NPP data
summary(lm(mpd.obs ~ log(treeheight*1000) + leafshape + ntaxa, data = trait_grid))
plot(lm(mpd.obs ~ log(treeheight*1000) + leafshape + ntaxa, data = trait_grid))

#map the residulals of ^^^

#calculate Moran's I for the residuals

```

#boosted regression model (mpd ~ everything) brt package in R
```{r boosted_regression, include =TRUE}
library(gbm)
```

#Check the ecotone region in the cape, it may explain why there is low species richness and high mpd

need to plan a spatial model: 
 1) include lat and long
 2) spatial eigenvectors


#Messing with stuff
```{r}
NPP_UWM<-raster("~/Downloads/NPP/npp/dblbnd.adf") #NPP (kg-C/m2/year) from IBIS Simulation “The Nelson Institute Center for Sustainability and the Global Environment, University of Wisconsin-Madison”
plot(NPP_UWM)

NPP_UWM$dblbnd
crs(NPP_UWM) <- CRS('+init=EPSG:4326')

mm<-raster("~/Downloads/dataverse_files/SynthesizedET_2012_01-0000000000-0000000000.tif")
plot(mm)


install.packages("BiocManager")
BiocManager::install("rhdf5")
library(rhdf5)
bio<-h5read("~/Downloads/GFED4.1s_2013.hdf5", "biosphere")
str(bio)

grids<-h5read("~/Downloads/GFED4.1s_2013.hdf5", "ancill")
plot(st_geometry(grids$grid_cell_area))

library(terra)
f <- "~/Downloads/GFED4.1s_2013.hdf5"
s <- sds(f)
s

r <- s$NPP

plot(r, 1)

# list all the `hdf5` files 
files <- list.files(path=".", pattern=paste(".*.h5",sep=""), all.files=FALSE, full.names=TRUE)
#choose the band that you want using the sds[] option and write GTiff files.
  for (i in (files)) {
  sds <- get_subdatasets(i)
  r2 <- gdal_translate(sds[1], dst_dataset =paste(i,".tif",sep=""))}

help<-raster("~/Downloads/GFED4.1s_2013.hdf5")

#ggplot(grids) +
#  geom_sf(data = bio, fill = NA, size = 0.3)

```

